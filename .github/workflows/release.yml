name: ğŸš€ Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false

env:
  GO_VERSION: '1.23'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ğŸ·ï¸ Prepare Release
  prepare:
    name: ğŸ·ï¸ Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: ğŸ·ï¸ Determine Version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
          IS_PRERELEASE="${{ github.event.inputs.prerelease }}"
        else
          VERSION=${GITHUB_REF#refs/tags/}
          if [[ $VERSION =~ -[a-zA-Z] ]]; then
            IS_PRERELEASE=true
          else
            IS_PRERELEASE=false
          fi
        fi
        
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "is_prerelease=${IS_PRERELEASE}" >> $GITHUB_OUTPUT
        
        echo "ğŸ·ï¸ Release Version: ${VERSION}"
        echo "ğŸ”– Pre-release: ${IS_PRERELEASE}"

  # ğŸ§ª Pre-Release Tests
  test:
    name: ğŸ§ª Pre-Release Tests
    runs-on: ubuntu-latest
    needs: prepare
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ğŸ¹ Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
    
    - name: ğŸ§ª Run Full Test Suite
      run: |
        echo "ğŸ§ª Running comprehensive test suite..."
        go test -v -short -race -coverprofile=coverage.out ./...
        go vet ./...
    
    - name: ğŸ—ï¸ Test Build
      run: |
        echo "ğŸ—ï¸ Testing build process..."
        go build -v -o gocat-test .
        ./gocat-test --help

  # ğŸ—ï¸ Multi-Platform Build
  build:
    name: ğŸ—ï¸ Build (${{ matrix.name }})
    runs-on: ubuntu-latest
    needs: [prepare, test]
    
    strategy:
      matrix:
        include:
          # Linux builds
          - name: Linux AMD64
            goos: linux
            goarch: amd64
            artifact: gocat-${{ needs.prepare.outputs.version }}-linux-amd64
          - name: Linux ARM64
            goos: linux
            goarch: arm64
            artifact: gocat-${{ needs.prepare.outputs.version }}-linux-arm64
          - name: Linux ARM
            goos: linux
            goarch: arm
            goarm: 7
            artifact: gocat-${{ needs.prepare.outputs.version }}-linux-armv7
          
          # macOS builds
          - name: macOS AMD64
            goos: darwin
            goarch: amd64
            artifact: gocat-${{ needs.prepare.outputs.version }}-darwin-amd64
          - name: macOS ARM64
            goos: darwin
            goarch: arm64
            artifact: gocat-${{ needs.prepare.outputs.version }}-darwin-arm64
          
          # Windows builds
          - name: Windows AMD64
            goos: windows
            goarch: amd64
            artifact: gocat-${{ needs.prepare.outputs.version }}-windows-amd64.exe
          - name: Windows ARM64
            goos: windows
            goarch: arm64
            artifact: gocat-${{ needs.prepare.outputs.version }}-windows-arm64.exe
          
          # FreeBSD builds
          - name: FreeBSD AMD64
            goos: freebsd
            goarch: amd64
            artifact: gocat-${{ needs.prepare.outputs.version }}-freebsd-amd64
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: ğŸ¹ Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
    
    - name: ğŸ—ï¸ Build Binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        GOARM: ${{ matrix.goarm }}
        CGO_ENABLED: 0
      run: |
        echo "ğŸ—ï¸ Building ${{ matrix.name }}..."
        
        # Build metadata
        BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        GIT_COMMIT=$(git rev-parse --short HEAD)
        VERSION="${{ needs.prepare.outputs.version }}"
        
        # Optimized build flags
        LDFLAGS="
          -s -w
          -X main.version=${VERSION}
          -X main.buildTime=${BUILD_TIME}
          -X main.gitCommit=${GIT_COMMIT}
          -X main.builtBy=github-actions
        "
        
        # Build with optimizations
        go build \
          -trimpath \
          -buildmode=pie \
          -ldflags="${LDFLAGS}" \
          -o "${{ matrix.artifact }}" \
          .
        
        # Verify build
        ls -la "${{ matrix.artifact }}"
        file "${{ matrix.artifact }}"
        
        echo "âœ… Build completed: ${{ matrix.artifact }}"
    
    - name: ğŸ“¦ Create Archive
      run: |
        echo "ğŸ“¦ Creating release archive..."
        
        # Create directory structure
        ARCHIVE_NAME="gocat-${{ needs.prepare.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}"
        mkdir -p "${ARCHIVE_NAME}"
        
        # Copy binary
        cp "${{ matrix.artifact }}" "${ARCHIVE_NAME}/"
        
        # Copy documentation
        cp README.md "${ARCHIVE_NAME}/" 2>/dev/null || echo "README.md not found"
        cp LICENSE "${ARCHIVE_NAME}/" 2>/dev/null || echo "LICENSE not found"
        
        # Create installation script
        cat > "${ARCHIVE_NAME}/install.sh" << 'EOF'
        #!/bin/bash
        echo "ğŸš€ Installing GoCat..."
        
        BINARY_NAME="${{ matrix.artifact }}"
        INSTALL_DIR="${INSTALL_DIR:-/usr/local/bin}"
        
        if [ -w "$INSTALL_DIR" ]; then
            cp "$BINARY_NAME" "$INSTALL_DIR/gocat"
        else
            sudo cp "$BINARY_NAME" "$INSTALL_DIR/gocat"
        fi
        
        chmod +x "$INSTALL_DIR/gocat"
        echo "âœ… GoCat installed to $INSTALL_DIR/gocat"
        echo "ğŸ‰ Run 'gocat --help' to get started!"
        EOF
        
        chmod +x "${ARCHIVE_NAME}/install.sh"
        
        # Create archive
        if [[ "${{ matrix.goos }}" == "windows" ]]; then
          zip -r "${ARCHIVE_NAME}.zip" "${ARCHIVE_NAME}"
          echo "archive=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
        else
          tar -czf "${ARCHIVE_NAME}.tar.gz" "${ARCHIVE_NAME}"
          echo "archive=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
        fi
        
        echo "ğŸ“¦ Archive created: ${archive}"
    
    - name: ğŸ“¤ Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: |
          ${{ matrix.artifact }}
          ${{ env.archive }}
        retention-days: 30

  # ğŸ“¦ Package Creation
  packages:
    name: ğŸ“¦ Create Packages
    runs-on: ubuntu-latest
    needs: [prepare, build]
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ğŸ“¥ Download Linux AMD64 Binary
      uses: actions/download-artifact@v4
      with:
        name: gocat-${{ needs.prepare.outputs.version }}-linux-amd64
        path: ./
    
    - name: ğŸ”§ Setup Package Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y dpkg-dev rpm alien
    
    - name: ğŸ“¦ Create Debian Package
      run: |
        echo "ğŸ“¦ Creating Debian package..."
        
        # Prepare binary
        chmod +x "gocat-${{ needs.prepare.outputs.version }}-linux-amd64"
        cp "gocat-${{ needs.prepare.outputs.version }}-linux-amd64" gocat
        
        # Build package
        chmod +x pkg/Debian/build-deb.sh
        cd pkg/Debian
        VERSION=$(echo "${{ needs.prepare.outputs.version }}" | sed 's/^v//')
        ./build-deb.sh "${VERSION}" amd64
        
        # Move package to root
        mv *.deb ../../
        cd ../..
        
        echo "âœ… Debian package created"
        ls -la *.deb
    
    - name: ğŸ“¦ Create RPM Package
      run: |
        echo "ğŸ“¦ Creating RPM package..."
        
        # Convert DEB to RPM
        DEB_FILE=$(ls *.deb | head -1)
        sudo alien -r "$DEB_FILE"
        
        echo "âœ… RPM package created"
        ls -la *.rpm
    
    - name: ğŸ“¤ Upload Package Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: packages
        path: |
          *.deb
          *.rpm
        retention-days: 30

  # ğŸ³ Docker Image
  docker:
    name: ğŸ³ Build Docker Image
    runs-on: ubuntu-latest
    needs: [prepare, build]
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ğŸ“¥ Download Linux AMD64 Binary
      uses: actions/download-artifact@v4
      with:
        name: gocat-${{ needs.prepare.outputs.version }}-linux-amd64
        path: ./
    
    - name: ğŸ”§ Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: ğŸ”‘ Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: ğŸ·ï¸ Extract Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=tag
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
    
    - name: ğŸ³ Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          VERSION=${{ needs.prepare.outputs.version }}
          BINARY_PATH=./gocat-${{ needs.prepare.outputs.version }}-linux-amd64

  # ğŸš€ Create Release
  release:
    name: ğŸš€ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare, test, build, packages, docker]
    permissions:
      contents: write
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: ğŸ“¥ Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts
    
    - name: ğŸ“ Generate Release Notes
      id: release_notes
      run: |
        echo "ğŸ“ Generating release notes..."
        
        # Get previous tag
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        
        # Generate changelog
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "## ğŸ‰ What's New in ${{ needs.prepare.outputs.version }}" > release_notes.md
          echo "" >> release_notes.md
          
          # Get commits since last tag
          git log --pretty=format:"- %s" "$PREVIOUS_TAG"..HEAD >> release_notes.md
          echo "" >> release_notes.md
        else
          echo "## ğŸ‰ Initial Release ${{ needs.prepare.outputs.version }}" > release_notes.md
          echo "" >> release_notes.md
          echo "- Initial release of GoCat - Modern netcat alternative" >> release_notes.md
        fi
        
        # Add features section
        cat >> release_notes.md << 'EOF'
        
        ## âœ¨ Features
        - ğŸŒ Full IPv6 support with proper address formatting
        - ğŸ¯ Multiple connection modes (Normal, Interactive, Local Interactive)
        - ğŸ¨ Colored logging output
        - ğŸ”„ Signal handling and graceful shutdown
        - ğŸ“± Cross-platform support (Linux, macOS, Windows, FreeBSD)
        - ğŸ“ Command history in interactive mode
        - ğŸ”§ Enhanced error handling and debugging
        
        ## ğŸ“¦ Installation
        
        ### Quick Install (Linux/macOS)
        ```bash
        curl -sSL https://raw.githubusercontent.com/ibrahmsql/gocat/main/pkg/install.sh | bash
        ```
        
        ### Package Managers
        - **Debian/Ubuntu**: Download `.deb` package from assets
        - **RHEL/CentOS**: Download `.rpm` package from assets
        - **Arch Linux**: Use the PKGBUILD from `pkg/arch/`
        
        ### Docker
        ```bash
        docker run --rm ghcr.io/ibrahmsql/gocat:${{ needs.prepare.outputs.version }} --help
        ```
        
        ## ğŸš€ Usage Examples
        
        ```bash
        # Start a listener
        gocat listen 8080
        
        # Connect to a host
        gocat connect example.com 8080
        
        # Interactive mode
        gocat listen -i 8080
        
        # Local interactive mode
        gocat listen -l 8080
        ```
        EOF
        
        echo "release_notes_file=release_notes.md" >> $GITHUB_OUTPUT
    
    - name: ğŸ“¦ Prepare Release Assets
      run: |
        echo "ğŸ“¦ Preparing release assets..."
        
        mkdir -p release_assets
        
        # Copy all build artifacts
        find artifacts -name "*.tar.gz" -o -name "*.zip" -o -name "*.deb" -o -name "*.rpm" | while read file; do
          cp "$file" release_assets/
        done
        
        # List all assets
        echo "ğŸ“‹ Release assets:"
        ls -la release_assets/
    
    - name: ğŸš€ Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.prepare.outputs.version }}
        name: "ğŸš€ GoCat ${{ needs.prepare.outputs.version }}"
        body_path: ${{ steps.release_notes.outputs.release_notes_file }}
        prerelease: ${{ needs.prepare.outputs.is_prerelease }}
        files: release_assets/*
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ğŸ“¢ Post-Release Notifications
  notify:
    name: ğŸ“¢ Post-Release Notifications
    runs-on: ubuntu-latest
    needs: [prepare, release]
    if: always() && needs.release.result == 'success'
    
    steps:
    - name: ğŸ“¢ Success Notification
      run: |
        echo "ğŸ‰ Release ${{ needs.prepare.outputs.version }} completed successfully!"
        echo "ğŸ“¦ Packages and binaries are now available"
        echo "ğŸ³ Docker image pushed to registry"
        echo "ğŸ“ Release notes generated and published"
        
        # Here you could add Slack, Discord, or email notifications
        # Example:
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"ğŸ‰ GoCat ${{ needs.prepare.outputs.version }} released!"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}